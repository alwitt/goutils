// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mockgoutils

import (
	"context"
	"reflect"
	"sync"

	"github.com/alwitt/goutils"
	mock "github.com/stretchr/testify/mock"
)

// NewTaskProcessor creates a new instance of TaskProcessor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTaskProcessor(t interface {
	mock.TestingT
	Cleanup(func())
}) *TaskProcessor {
	mock := &TaskProcessor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TaskProcessor is an autogenerated mock type for the TaskProcessor type
type TaskProcessor struct {
	mock.Mock
}

type TaskProcessor_Expecter struct {
	mock *mock.Mock
}

func (_m *TaskProcessor) EXPECT() *TaskProcessor_Expecter {
	return &TaskProcessor_Expecter{mock: &_m.Mock}
}

// AddToTaskExecutionMap provides a mock function for the type TaskProcessor
func (_mock *TaskProcessor) AddToTaskExecutionMap(parameterType reflect.Type, handler goutils.TaskProcessorSupportHandler) error {
	ret := _mock.Called(parameterType, handler)

	if len(ret) == 0 {
		panic("no return value specified for AddToTaskExecutionMap")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(reflect.Type, goutils.TaskProcessorSupportHandler) error); ok {
		r0 = returnFunc(parameterType, handler)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TaskProcessor_AddToTaskExecutionMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToTaskExecutionMap'
type TaskProcessor_AddToTaskExecutionMap_Call struct {
	*mock.Call
}

// AddToTaskExecutionMap is a helper method to define mock.On call
//   - parameterType reflect.Type
//   - handler goutils.TaskProcessorSupportHandler
func (_e *TaskProcessor_Expecter) AddToTaskExecutionMap(parameterType interface{}, handler interface{}) *TaskProcessor_AddToTaskExecutionMap_Call {
	return &TaskProcessor_AddToTaskExecutionMap_Call{Call: _e.mock.On("AddToTaskExecutionMap", parameterType, handler)}
}

func (_c *TaskProcessor_AddToTaskExecutionMap_Call) Run(run func(parameterType reflect.Type, handler goutils.TaskProcessorSupportHandler)) *TaskProcessor_AddToTaskExecutionMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 reflect.Type
		if args[0] != nil {
			arg0 = args[0].(reflect.Type)
		}
		var arg1 goutils.TaskProcessorSupportHandler
		if args[1] != nil {
			arg1 = args[1].(goutils.TaskProcessorSupportHandler)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TaskProcessor_AddToTaskExecutionMap_Call) Return(err error) *TaskProcessor_AddToTaskExecutionMap_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TaskProcessor_AddToTaskExecutionMap_Call) RunAndReturn(run func(parameterType reflect.Type, handler goutils.TaskProcessorSupportHandler) error) *TaskProcessor_AddToTaskExecutionMap_Call {
	_c.Call.Return(run)
	return _c
}

// SetTaskExecutionMap provides a mock function for the type TaskProcessor
func (_mock *TaskProcessor) SetTaskExecutionMap(newMap map[reflect.Type]goutils.TaskProcessorSupportHandler) error {
	ret := _mock.Called(newMap)

	if len(ret) == 0 {
		panic("no return value specified for SetTaskExecutionMap")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(map[reflect.Type]goutils.TaskProcessorSupportHandler) error); ok {
		r0 = returnFunc(newMap)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TaskProcessor_SetTaskExecutionMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTaskExecutionMap'
type TaskProcessor_SetTaskExecutionMap_Call struct {
	*mock.Call
}

// SetTaskExecutionMap is a helper method to define mock.On call
//   - newMap map[reflect.Type]goutils.TaskProcessorSupportHandler
func (_e *TaskProcessor_Expecter) SetTaskExecutionMap(newMap interface{}) *TaskProcessor_SetTaskExecutionMap_Call {
	return &TaskProcessor_SetTaskExecutionMap_Call{Call: _e.mock.On("SetTaskExecutionMap", newMap)}
}

func (_c *TaskProcessor_SetTaskExecutionMap_Call) Run(run func(newMap map[reflect.Type]goutils.TaskProcessorSupportHandler)) *TaskProcessor_SetTaskExecutionMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 map[reflect.Type]goutils.TaskProcessorSupportHandler
		if args[0] != nil {
			arg0 = args[0].(map[reflect.Type]goutils.TaskProcessorSupportHandler)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TaskProcessor_SetTaskExecutionMap_Call) Return(err error) *TaskProcessor_SetTaskExecutionMap_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TaskProcessor_SetTaskExecutionMap_Call) RunAndReturn(run func(newMap map[reflect.Type]goutils.TaskProcessorSupportHandler) error) *TaskProcessor_SetTaskExecutionMap_Call {
	_c.Call.Return(run)
	return _c
}

// StartEventLoop provides a mock function for the type TaskProcessor
func (_mock *TaskProcessor) StartEventLoop(wg *sync.WaitGroup) error {
	ret := _mock.Called(wg)

	if len(ret) == 0 {
		panic("no return value specified for StartEventLoop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*sync.WaitGroup) error); ok {
		r0 = returnFunc(wg)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TaskProcessor_StartEventLoop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartEventLoop'
type TaskProcessor_StartEventLoop_Call struct {
	*mock.Call
}

// StartEventLoop is a helper method to define mock.On call
//   - wg *sync.WaitGroup
func (_e *TaskProcessor_Expecter) StartEventLoop(wg interface{}) *TaskProcessor_StartEventLoop_Call {
	return &TaskProcessor_StartEventLoop_Call{Call: _e.mock.On("StartEventLoop", wg)}
}

func (_c *TaskProcessor_StartEventLoop_Call) Run(run func(wg *sync.WaitGroup)) *TaskProcessor_StartEventLoop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *sync.WaitGroup
		if args[0] != nil {
			arg0 = args[0].(*sync.WaitGroup)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TaskProcessor_StartEventLoop_Call) Return(err error) *TaskProcessor_StartEventLoop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TaskProcessor_StartEventLoop_Call) RunAndReturn(run func(wg *sync.WaitGroup) error) *TaskProcessor_StartEventLoop_Call {
	_c.Call.Return(run)
	return _c
}

// StopEventLoop provides a mock function for the type TaskProcessor
func (_mock *TaskProcessor) StopEventLoop() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StopEventLoop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TaskProcessor_StopEventLoop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopEventLoop'
type TaskProcessor_StopEventLoop_Call struct {
	*mock.Call
}

// StopEventLoop is a helper method to define mock.On call
func (_e *TaskProcessor_Expecter) StopEventLoop() *TaskProcessor_StopEventLoop_Call {
	return &TaskProcessor_StopEventLoop_Call{Call: _e.mock.On("StopEventLoop")}
}

func (_c *TaskProcessor_StopEventLoop_Call) Run(run func()) *TaskProcessor_StopEventLoop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TaskProcessor_StopEventLoop_Call) Return(err error) *TaskProcessor_StopEventLoop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TaskProcessor_StopEventLoop_Call) RunAndReturn(run func() error) *TaskProcessor_StopEventLoop_Call {
	_c.Call.Return(run)
	return _c
}

// Submit provides a mock function for the type TaskProcessor
func (_mock *TaskProcessor) Submit(ctx context.Context, newTaskParam interface{}) error {
	ret := _mock.Called(ctx, newTaskParam)

	if len(ret) == 0 {
		panic("no return value specified for Submit")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, interface{}) error); ok {
		r0 = returnFunc(ctx, newTaskParam)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TaskProcessor_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type TaskProcessor_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - ctx context.Context
//   - newTaskParam interface{}
func (_e *TaskProcessor_Expecter) Submit(ctx interface{}, newTaskParam interface{}) *TaskProcessor_Submit_Call {
	return &TaskProcessor_Submit_Call{Call: _e.mock.On("Submit", ctx, newTaskParam)}
}

func (_c *TaskProcessor_Submit_Call) Run(run func(ctx context.Context, newTaskParam interface{})) *TaskProcessor_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 interface{}
		if args[1] != nil {
			arg1 = args[1].(interface{})
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TaskProcessor_Submit_Call) Return(err error) *TaskProcessor_Submit_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TaskProcessor_Submit_Call) RunAndReturn(run func(ctx context.Context, newTaskParam interface{}) error) *TaskProcessor_Submit_Call {
	_c.Call.Return(run)
	return _c
}
