// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mockgoutils

import (
	"context"

	"cloud.google.com/go/pubsub"
	"github.com/alwitt/goutils"
	mock "github.com/stretchr/testify/mock"
)

// NewPubSubClient creates a new instance of PubSubClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPubSubClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *PubSubClient {
	mock := &PubSubClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PubSubClient is an autogenerated mock type for the PubSubClient type
type PubSubClient struct {
	mock.Mock
}

type PubSubClient_Expecter struct {
	mock *mock.Mock
}

func (_m *PubSubClient) EXPECT() *PubSubClient_Expecter {
	return &PubSubClient_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type PubSubClient
func (_mock *PubSubClient) Close(ctxt context.Context) error {
	ret := _mock.Called(ctxt)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctxt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type PubSubClient_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctxt context.Context
func (_e *PubSubClient_Expecter) Close(ctxt interface{}) *PubSubClient_Close_Call {
	return &PubSubClient_Close_Call{Call: _e.mock.On("Close", ctxt)}
}

func (_c *PubSubClient_Close_Call) Run(run func(ctxt context.Context)) *PubSubClient_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubClient_Close_Call) Return(err error) *PubSubClient_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_Close_Call) RunAndReturn(run func(ctxt context.Context) error) *PubSubClient_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSubscription provides a mock function for the type PubSubClient
func (_mock *PubSubClient) CreateSubscription(ctxt context.Context, targetTopic string, subscription string, config pubsub.SubscriptionConfig) error {
	ret := _mock.Called(ctxt, targetTopic, subscription, config)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubscription")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, pubsub.SubscriptionConfig) error); ok {
		r0 = returnFunc(ctxt, targetTopic, subscription, config)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_CreateSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSubscription'
type PubSubClient_CreateSubscription_Call struct {
	*mock.Call
}

// CreateSubscription is a helper method to define mock.On call
//   - ctxt context.Context
//   - targetTopic string
//   - subscription string
//   - config pubsub.SubscriptionConfig
func (_e *PubSubClient_Expecter) CreateSubscription(ctxt interface{}, targetTopic interface{}, subscription interface{}, config interface{}) *PubSubClient_CreateSubscription_Call {
	return &PubSubClient_CreateSubscription_Call{Call: _e.mock.On("CreateSubscription", ctxt, targetTopic, subscription, config)}
}

func (_c *PubSubClient_CreateSubscription_Call) Run(run func(ctxt context.Context, targetTopic string, subscription string, config pubsub.SubscriptionConfig)) *PubSubClient_CreateSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 pubsub.SubscriptionConfig
		if args[3] != nil {
			arg3 = args[3].(pubsub.SubscriptionConfig)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *PubSubClient_CreateSubscription_Call) Return(err error) *PubSubClient_CreateSubscription_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_CreateSubscription_Call) RunAndReturn(run func(ctxt context.Context, targetTopic string, subscription string, config pubsub.SubscriptionConfig) error) *PubSubClient_CreateSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTopic provides a mock function for the type PubSubClient
func (_mock *PubSubClient) CreateTopic(ctxt context.Context, topic string, config *pubsub.TopicConfig) error {
	ret := _mock.Called(ctxt, topic, config)

	if len(ret) == 0 {
		panic("no return value specified for CreateTopic")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *pubsub.TopicConfig) error); ok {
		r0 = returnFunc(ctxt, topic, config)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_CreateTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTopic'
type PubSubClient_CreateTopic_Call struct {
	*mock.Call
}

// CreateTopic is a helper method to define mock.On call
//   - ctxt context.Context
//   - topic string
//   - config *pubsub.TopicConfig
func (_e *PubSubClient_Expecter) CreateTopic(ctxt interface{}, topic interface{}, config interface{}) *PubSubClient_CreateTopic_Call {
	return &PubSubClient_CreateTopic_Call{Call: _e.mock.On("CreateTopic", ctxt, topic, config)}
}

func (_c *PubSubClient_CreateTopic_Call) Run(run func(ctxt context.Context, topic string, config *pubsub.TopicConfig)) *PubSubClient_CreateTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *pubsub.TopicConfig
		if args[2] != nil {
			arg2 = args[2].(*pubsub.TopicConfig)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PubSubClient_CreateTopic_Call) Return(err error) *PubSubClient_CreateTopic_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_CreateTopic_Call) RunAndReturn(run func(ctxt context.Context, topic string, config *pubsub.TopicConfig) error) *PubSubClient_CreateTopic_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSubscription provides a mock function for the type PubSubClient
func (_mock *PubSubClient) DeleteSubscription(ctxt context.Context, subscription string) error {
	ret := _mock.Called(ctxt, subscription)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubscription")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctxt, subscription)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_DeleteSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSubscription'
type PubSubClient_DeleteSubscription_Call struct {
	*mock.Call
}

// DeleteSubscription is a helper method to define mock.On call
//   - ctxt context.Context
//   - subscription string
func (_e *PubSubClient_Expecter) DeleteSubscription(ctxt interface{}, subscription interface{}) *PubSubClient_DeleteSubscription_Call {
	return &PubSubClient_DeleteSubscription_Call{Call: _e.mock.On("DeleteSubscription", ctxt, subscription)}
}

func (_c *PubSubClient_DeleteSubscription_Call) Run(run func(ctxt context.Context, subscription string)) *PubSubClient_DeleteSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubClient_DeleteSubscription_Call) Return(err error) *PubSubClient_DeleteSubscription_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_DeleteSubscription_Call) RunAndReturn(run func(ctxt context.Context, subscription string) error) *PubSubClient_DeleteSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTopic provides a mock function for the type PubSubClient
func (_mock *PubSubClient) DeleteTopic(ctxt context.Context, topic string) error {
	ret := _mock.Called(ctxt, topic)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTopic")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctxt, topic)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_DeleteTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTopic'
type PubSubClient_DeleteTopic_Call struct {
	*mock.Call
}

// DeleteTopic is a helper method to define mock.On call
//   - ctxt context.Context
//   - topic string
func (_e *PubSubClient_Expecter) DeleteTopic(ctxt interface{}, topic interface{}) *PubSubClient_DeleteTopic_Call {
	return &PubSubClient_DeleteTopic_Call{Call: _e.mock.On("DeleteTopic", ctxt, topic)}
}

func (_c *PubSubClient_DeleteTopic_Call) Run(run func(ctxt context.Context, topic string)) *PubSubClient_DeleteTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubClient_DeleteTopic_Call) Return(err error) *PubSubClient_DeleteTopic_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_DeleteTopic_Call) RunAndReturn(run func(ctxt context.Context, topic string) error) *PubSubClient_DeleteTopic_Call {
	_c.Call.Return(run)
	return _c
}

// GetSubscription provides a mock function for the type PubSubClient
func (_mock *PubSubClient) GetSubscription(ctxt context.Context, subscription string) (pubsub.SubscriptionConfig, error) {
	ret := _mock.Called(ctxt, subscription)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscription")
	}

	var r0 pubsub.SubscriptionConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (pubsub.SubscriptionConfig, error)); ok {
		return returnFunc(ctxt, subscription)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) pubsub.SubscriptionConfig); ok {
		r0 = returnFunc(ctxt, subscription)
	} else {
		r0 = ret.Get(0).(pubsub.SubscriptionConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctxt, subscription)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PubSubClient_GetSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSubscription'
type PubSubClient_GetSubscription_Call struct {
	*mock.Call
}

// GetSubscription is a helper method to define mock.On call
//   - ctxt context.Context
//   - subscription string
func (_e *PubSubClient_Expecter) GetSubscription(ctxt interface{}, subscription interface{}) *PubSubClient_GetSubscription_Call {
	return &PubSubClient_GetSubscription_Call{Call: _e.mock.On("GetSubscription", ctxt, subscription)}
}

func (_c *PubSubClient_GetSubscription_Call) Run(run func(ctxt context.Context, subscription string)) *PubSubClient_GetSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubClient_GetSubscription_Call) Return(subscriptionConfig pubsub.SubscriptionConfig, err error) *PubSubClient_GetSubscription_Call {
	_c.Call.Return(subscriptionConfig, err)
	return _c
}

func (_c *PubSubClient_GetSubscription_Call) RunAndReturn(run func(ctxt context.Context, subscription string) (pubsub.SubscriptionConfig, error)) *PubSubClient_GetSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// GetTopic provides a mock function for the type PubSubClient
func (_mock *PubSubClient) GetTopic(ctxt context.Context, topic string) (pubsub.TopicConfig, error) {
	ret := _mock.Called(ctxt, topic)

	if len(ret) == 0 {
		panic("no return value specified for GetTopic")
	}

	var r0 pubsub.TopicConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (pubsub.TopicConfig, error)); ok {
		return returnFunc(ctxt, topic)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) pubsub.TopicConfig); ok {
		r0 = returnFunc(ctxt, topic)
	} else {
		r0 = ret.Get(0).(pubsub.TopicConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctxt, topic)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PubSubClient_GetTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTopic'
type PubSubClient_GetTopic_Call struct {
	*mock.Call
}

// GetTopic is a helper method to define mock.On call
//   - ctxt context.Context
//   - topic string
func (_e *PubSubClient_Expecter) GetTopic(ctxt interface{}, topic interface{}) *PubSubClient_GetTopic_Call {
	return &PubSubClient_GetTopic_Call{Call: _e.mock.On("GetTopic", ctxt, topic)}
}

func (_c *PubSubClient_GetTopic_Call) Run(run func(ctxt context.Context, topic string)) *PubSubClient_GetTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PubSubClient_GetTopic_Call) Return(topicConfig pubsub.TopicConfig, err error) *PubSubClient_GetTopic_Call {
	_c.Call.Return(topicConfig, err)
	return _c
}

func (_c *PubSubClient_GetTopic_Call) RunAndReturn(run func(ctxt context.Context, topic string) (pubsub.TopicConfig, error)) *PubSubClient_GetTopic_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type PubSubClient
func (_mock *PubSubClient) Publish(ctxt context.Context, topic string, message []byte, metadata map[string]string, blocking bool) (*pubsub.PublishResult, error) {
	ret := _mock.Called(ctxt, topic, message, metadata, blocking)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *pubsub.PublishResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte, map[string]string, bool) (*pubsub.PublishResult, error)); ok {
		return returnFunc(ctxt, topic, message, metadata, blocking)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []byte, map[string]string, bool) *pubsub.PublishResult); ok {
		r0 = returnFunc(ctxt, topic, message, metadata, blocking)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.PublishResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []byte, map[string]string, bool) error); ok {
		r1 = returnFunc(ctxt, topic, message, metadata, blocking)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PubSubClient_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type PubSubClient_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctxt context.Context
//   - topic string
//   - message []byte
//   - metadata map[string]string
//   - blocking bool
func (_e *PubSubClient_Expecter) Publish(ctxt interface{}, topic interface{}, message interface{}, metadata interface{}, blocking interface{}) *PubSubClient_Publish_Call {
	return &PubSubClient_Publish_Call{Call: _e.mock.On("Publish", ctxt, topic, message, metadata, blocking)}
}

func (_c *PubSubClient_Publish_Call) Run(run func(ctxt context.Context, topic string, message []byte, metadata map[string]string, blocking bool)) *PubSubClient_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []byte
		if args[2] != nil {
			arg2 = args[2].([]byte)
		}
		var arg3 map[string]string
		if args[3] != nil {
			arg3 = args[3].(map[string]string)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *PubSubClient_Publish_Call) Return(v *pubsub.PublishResult, err error) *PubSubClient_Publish_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *PubSubClient_Publish_Call) RunAndReturn(run func(ctxt context.Context, topic string, message []byte, metadata map[string]string, blocking bool) (*pubsub.PublishResult, error)) *PubSubClient_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type PubSubClient
func (_mock *PubSubClient) Subscribe(ctxt context.Context, subscription string, handler goutils.PubSubMessageHandler) error {
	ret := _mock.Called(ctxt, subscription, handler)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, goutils.PubSubMessageHandler) error); ok {
		r0 = returnFunc(ctxt, subscription, handler)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type PubSubClient_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctxt context.Context
//   - subscription string
//   - handler goutils.PubSubMessageHandler
func (_e *PubSubClient_Expecter) Subscribe(ctxt interface{}, subscription interface{}, handler interface{}) *PubSubClient_Subscribe_Call {
	return &PubSubClient_Subscribe_Call{Call: _e.mock.On("Subscribe", ctxt, subscription, handler)}
}

func (_c *PubSubClient_Subscribe_Call) Run(run func(ctxt context.Context, subscription string, handler goutils.PubSubMessageHandler)) *PubSubClient_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 goutils.PubSubMessageHandler
		if args[2] != nil {
			arg2 = args[2].(goutils.PubSubMessageHandler)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PubSubClient_Subscribe_Call) Return(err error) *PubSubClient_Subscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_Subscribe_Call) RunAndReturn(run func(ctxt context.Context, subscription string, handler goutils.PubSubMessageHandler) error) *PubSubClient_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLocalSubscriptionCache provides a mock function for the type PubSubClient
func (_mock *PubSubClient) UpdateLocalSubscriptionCache(ctxt context.Context) error {
	ret := _mock.Called(ctxt)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLocalSubscriptionCache")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctxt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_UpdateLocalSubscriptionCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLocalSubscriptionCache'
type PubSubClient_UpdateLocalSubscriptionCache_Call struct {
	*mock.Call
}

// UpdateLocalSubscriptionCache is a helper method to define mock.On call
//   - ctxt context.Context
func (_e *PubSubClient_Expecter) UpdateLocalSubscriptionCache(ctxt interface{}) *PubSubClient_UpdateLocalSubscriptionCache_Call {
	return &PubSubClient_UpdateLocalSubscriptionCache_Call{Call: _e.mock.On("UpdateLocalSubscriptionCache", ctxt)}
}

func (_c *PubSubClient_UpdateLocalSubscriptionCache_Call) Run(run func(ctxt context.Context)) *PubSubClient_UpdateLocalSubscriptionCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubClient_UpdateLocalSubscriptionCache_Call) Return(err error) *PubSubClient_UpdateLocalSubscriptionCache_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_UpdateLocalSubscriptionCache_Call) RunAndReturn(run func(ctxt context.Context) error) *PubSubClient_UpdateLocalSubscriptionCache_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLocalTopicCache provides a mock function for the type PubSubClient
func (_mock *PubSubClient) UpdateLocalTopicCache(ctxt context.Context) error {
	ret := _mock.Called(ctxt)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLocalTopicCache")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctxt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_UpdateLocalTopicCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLocalTopicCache'
type PubSubClient_UpdateLocalTopicCache_Call struct {
	*mock.Call
}

// UpdateLocalTopicCache is a helper method to define mock.On call
//   - ctxt context.Context
func (_e *PubSubClient_Expecter) UpdateLocalTopicCache(ctxt interface{}) *PubSubClient_UpdateLocalTopicCache_Call {
	return &PubSubClient_UpdateLocalTopicCache_Call{Call: _e.mock.On("UpdateLocalTopicCache", ctxt)}
}

func (_c *PubSubClient_UpdateLocalTopicCache_Call) Run(run func(ctxt context.Context)) *PubSubClient_UpdateLocalTopicCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PubSubClient_UpdateLocalTopicCache_Call) Return(err error) *PubSubClient_UpdateLocalTopicCache_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_UpdateLocalTopicCache_Call) RunAndReturn(run func(ctxt context.Context) error) *PubSubClient_UpdateLocalTopicCache_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSubscription provides a mock function for the type PubSubClient
func (_mock *PubSubClient) UpdateSubscription(ctxt context.Context, subscription string, newConfig pubsub.SubscriptionConfigToUpdate) error {
	ret := _mock.Called(ctxt, subscription, newConfig)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubscription")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pubsub.SubscriptionConfigToUpdate) error); ok {
		r0 = returnFunc(ctxt, subscription, newConfig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_UpdateSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSubscription'
type PubSubClient_UpdateSubscription_Call struct {
	*mock.Call
}

// UpdateSubscription is a helper method to define mock.On call
//   - ctxt context.Context
//   - subscription string
//   - newConfig pubsub.SubscriptionConfigToUpdate
func (_e *PubSubClient_Expecter) UpdateSubscription(ctxt interface{}, subscription interface{}, newConfig interface{}) *PubSubClient_UpdateSubscription_Call {
	return &PubSubClient_UpdateSubscription_Call{Call: _e.mock.On("UpdateSubscription", ctxt, subscription, newConfig)}
}

func (_c *PubSubClient_UpdateSubscription_Call) Run(run func(ctxt context.Context, subscription string, newConfig pubsub.SubscriptionConfigToUpdate)) *PubSubClient_UpdateSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 pubsub.SubscriptionConfigToUpdate
		if args[2] != nil {
			arg2 = args[2].(pubsub.SubscriptionConfigToUpdate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PubSubClient_UpdateSubscription_Call) Return(err error) *PubSubClient_UpdateSubscription_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_UpdateSubscription_Call) RunAndReturn(run func(ctxt context.Context, subscription string, newConfig pubsub.SubscriptionConfigToUpdate) error) *PubSubClient_UpdateSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTopic provides a mock function for the type PubSubClient
func (_mock *PubSubClient) UpdateTopic(ctxt context.Context, topic string, newConfig pubsub.TopicConfigToUpdate) error {
	ret := _mock.Called(ctxt, topic, newConfig)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTopic")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pubsub.TopicConfigToUpdate) error); ok {
		r0 = returnFunc(ctxt, topic, newConfig)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// PubSubClient_UpdateTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTopic'
type PubSubClient_UpdateTopic_Call struct {
	*mock.Call
}

// UpdateTopic is a helper method to define mock.On call
//   - ctxt context.Context
//   - topic string
//   - newConfig pubsub.TopicConfigToUpdate
func (_e *PubSubClient_Expecter) UpdateTopic(ctxt interface{}, topic interface{}, newConfig interface{}) *PubSubClient_UpdateTopic_Call {
	return &PubSubClient_UpdateTopic_Call{Call: _e.mock.On("UpdateTopic", ctxt, topic, newConfig)}
}

func (_c *PubSubClient_UpdateTopic_Call) Run(run func(ctxt context.Context, topic string, newConfig pubsub.TopicConfigToUpdate)) *PubSubClient_UpdateTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 pubsub.TopicConfigToUpdate
		if args[2] != nil {
			arg2 = args[2].(pubsub.TopicConfigToUpdate)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *PubSubClient_UpdateTopic_Call) Return(err error) *PubSubClient_UpdateTopic_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *PubSubClient_UpdateTopic_Call) RunAndReturn(run func(ctxt context.Context, topic string, newConfig pubsub.TopicConfigToUpdate) error) *PubSubClient_UpdateTopic_Call {
	_c.Call.Return(run)
	return _c
}
